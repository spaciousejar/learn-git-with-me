---
title: Git Add
description: Master the git add command with comprehensive examples, visual diagrams, and best practices for staging changes effectively in your Git workflow.
---

## What is Git Add?

The `git add` command is your **gateway to version control**. It moves changes from your working directory to the staging area, preparing them for the next commit. Think of it as choosing which changes you want to include in your next snapshot of the project.

### Why Use Git Add?

1. **Selective Commits**: Choose exactly which changes to include
2. **Review Changes**: Stage changes incrementally and review before committing
3. **Organized History**: Create logical, focused commits
4. **Collaboration**: Prepare clean, reviewable changes for your team

## Visual Understanding of Git Add

### The Three States of Git

```
Working Directory    Staging Area (Index)    Git Repository
     (Modified)           (Staged)              (Committed)
         |                    |                      |
         |  git add           |  git commit          |
    [file.txt*] --------> [file.txt] --------> [file.txt]
         |                    |                      |
    Your changes         Changes ready         Permanent
    not tracked          for next commit       snapshot
```

### Before Git Add
```
Working Directory:
├── index.html (modified) *
├── styles.css (new file) *
├── script.js (unchanged)
└── README.md (unchanged)

Staging Area: (empty)

Git Repository: (previous commits)
```

### After Git Add
```
Working Directory:
├── index.html (modified)
├── styles.css (new file)
├── script.js (unchanged)
└── README.md (unchanged)

Staging Area:
├── index.html (staged) ✓
└── styles.css (staged) ✓

Git Repository: (previous commits)
```

## Basic Git Add Commands

### Add Single File
```bash
git add filename.txt
```

**When to use**: When you want to stage one specific file.

**Example Scenario**: You've fixed a bug in `payment.js` but also made experimental changes in `feature.js`. You only want to commit the bug fix.

```bash
# Stage only the bug fix
git add payment.js

# Check what's staged
git status
```

**Expected Output**:
```
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   payment.js

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
        modified:   feature.js
```

### Add Multiple Specific Files
```bash
git add file1.txt file2.css file3.js
```

**Example**:
```bash
# Stage related changes together
git add login.html login.css login.js
git commit -m "Add complete login functionality"
```

### Add All Files in Directory
```bash
git add .
```

**When to use**: When you want to stage all changes in the current directory and its subdirectories.

**Example Scenario**: You've completed a feature and all changes are ready to commit.

```bash
# Stage all changes
git add .

# Verify what's staged
git status --short
```

**Expected Output**:
```
A  new-feature.js
M  existing-file.js
D  old-file.js
```

### Add All Changes (Globally)
```bash
git add -A
```
or
```bash
git add --all
```

**When to use**: When you want to stage all changes across the entire repository, including deletions.

**Difference from `git add .`**:
- `git add .`: Stages changes in current directory and below
- `git add -A`: Stages changes throughout entire repository

### Add All Modified Files (Exclude New Files)
```bash
git add -u
```
or
```bash
git add --update
```

**When to use**: When you want to stage only files that Git is already tracking (excludes new files).

## Advanced Git Add Options

### Interactive Staging
```bash
git add -i
```

**What it does**: Opens an interactive menu for selective staging.

**Example Session**:
```bash
git add -i
```

**Interactive Menu**:
```
           staged     unstaged path
  1:    unchanged       +10/-2 src/app.js
  2:    unchanged        +5/-0 src/styles.css
  3:    unchanged        +1/-1 README.md

*** Commands ***
  1: [s]tatus     2: [u]pdate     3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff       7: [q]uit       8: [h]elp
What now> u
```

### Patch Mode (Selective Line Staging)
```bash
git add -p filename.txt
```
or
```bash
git add --patch filename.txt
```

**What it does**: Allows you to stage specific lines or hunks within a file.

**Example Scenario**: You've made two unrelated changes in the same file but want to commit them separately.

**Interactive Session**:
```bash
git add -p app.js
```

**Output**:
```
diff --git a/app.js b/app.js
index 1234567..abcdefg 100644
--- a/app.js
+++ b/app.js
@@ -10,6 +10,10 @@ function login(user) {
     console.log('User logged in');
 }
 
+function validateEmail(email) {
+    return email.includes('@');
+}
+
 function logout() {
     console.log('User logged out');
 }
Stage this hunk [y,n,q,a,d,s,e,?]?
```

**Options**:
- `y` - stage this hunk
- `n` - do not stage this hunk  
- `s` - split hunk into smaller parts
- `e` - manually edit the hunk
- `q` - quit

## Real-World Scenarios

### Scenario 1: Bug Fix with Unrelated Changes

**Situation**: You're working on a new feature but discover a critical bug.

**Problem**: You have both bug fix and incomplete feature code in your working directory.

**Solution**: Use selective staging.

```bash
# Current changes
git status --short
# M  payment.js    (bug fix - ready)
# M  feature.js    (new feature - not ready)
# ?? temp.js       (temporary file - ignore)

# Stage only the bug fix
git add payment.js

# Commit the bug fix
git commit -m "Fix payment validation bug"

# Continue working on feature
# feature.js and temp.js remain unstaged
```

### Scenario 2: Organizing Large Changes

**Situation**: You've refactored multiple components and want to create logical commits.

**Step-by-Step Process**:

```bash
# See all changes
git status
# Modified: header.js, footer.js, sidebar.js, styles.css, README.md

# Group 1: Component refactoring
git add header.js footer.js sidebar.js
git commit -m "Refactor navigation components"

# Group 2: Style updates
git add styles.css  
git commit -m "Update component styling"

# Group 3: Documentation
git add README.md
git commit -m "Update documentation for component changes"
```

### Scenario 3: Handling New Files and Deletions

**Situation**: You've reorganized your project structure.

```bash
# Project restructure
git status
# deleted:    old-folder/component.js
# new file:   src/components/component.js
# modified:   package.json

# Stage everything including deletions
git add -A

# Or stage incrementally
git add src/components/component.js  # new file
git add old-folder/component.js      # deletion
git add package.json                 # modification
```

## Git Add Best Practices

### 1. Review Before Adding
```bash
# See what changed
git diff

# See what would be added
git diff --cached

# Check status frequently
git status
```

### 2. Use Descriptive Commit Groups
```bash
# Group related changes
git add authentication/
git commit -m "Add user authentication system"

git add database/migrations/
git commit -m "Add user table migration"
```

### 3. Avoid Adding Everything Blindly
```bash
# ❌ Don't do this without reviewing
git add .
git commit -m "Various changes"

# ✅ Do this instead
git status
git diff
git add specific-files
git commit -m "Descriptive message"
```

### 4. Use .gitignore for Unwanted Files
```bash
# Create .gitignore to exclude files
echo "*.log" >> .gitignore
echo "node_modules/" >> .gitignore
echo ".env" >> .gitignore

# Add .gitignore itself
git add .gitignore
git commit -m "Add gitignore file"
```

## Understanding Git Add Output

### Git Status After Add
```bash
git add app.js styles.css
git status
```

**Output Explanation**:
```
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   app.js
        new file:   styles.css

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        temp.js
```

**What each section means**:
- **Changes to be committed**: Files staged and ready for next commit
- **Changes not staged**: Modified tracked files not yet staged
- **Untracked files**: New files Git doesn't know about

### Git Diff After Add
```bash
# Show unstaged changes
git diff

# Show staged changes
git diff --cached
# or
git diff --staged
```

## Common Git Add Patterns

### Pattern 1: Feature Development Workflow
```bash
# Start working on feature
git checkout -b feature/user-profile

# Make changes
# ... edit files ...

# Review changes
git diff

# Stage incrementally
git add user-profile.html
git add user-profile.css
git commit -m "Add user profile UI components"

git add user-profile.js
git commit -m "Add user profile functionality"

git add user-profile.test.js
git commit -m "Add user profile tests"
```

### Pattern 2: Bug Fix Workflow
```bash
# Identify bug files
git status

# Stage only bug fix files
git add payment-processor.js error-handler.js

# Commit bug fix
git commit -m "Fix payment processing error handling"

# Continue with other work...
```

### Pattern 3: Code Review Preparation
```bash
# Prepare clean commits for review
git add --patch

# Create focused commits
git commit -m "Extract validation logic to utils"

git add remaining-files
git commit -m "Update components to use new validation"
```

## Troubleshooting Git Add

### Issue 1: File Won't Stage
**Problem**: `git add` seems to do nothing

**Check**:
```bash
# Is the file actually changed?
git diff filename.txt

# Is the file ignored?
git check-ignore filename.txt

# Is the file already staged?
git diff --staged filename.txt
```

### Issue 2: Accidentally Staged Wrong Files
**Solution**:
```bash
# Unstage specific file
git restore --staged filename.txt

# Unstage all files
git restore --staged .

# Check what's still staged
git status
```

### Issue 3: Want to Stage Only Part of File
**Solution**:
```bash
# Use patch mode
git add -p filename.txt

# Or use interactive mode
git add -i
```

## Git Add Cheat Sheet

| Command | Purpose |
|---------|---------|
| `git add <file>` | Stage specific file |
| `git add .` | Stage all changes in current directory |
| `git add -A` | Stage all changes in repository |
| `git add -u` | Stage only modified tracked files |
| `git add -p` | Interactive line-by-line staging |
| `git add -i` | Interactive staging menu |
| `git restore --staged <file>` | Unstage file |
| `git diff` | See unstaged changes |
| `git diff --staged` | See staged changes |

#### Free Resources

<Tabs defaultValue="official">
<TabsList>
<TabsTrigger value="official">Official Docs</TabsTrigger>
<TabsTrigger value="article">Articles</TabsTrigger>
<TabsTrigger value="video">Videos</TabsTrigger>
</TabsList>

<TabsContent value="official">
<Note type="note" title="official">
- <Link href="https://git-scm.com/docs/git-add">Git Add Official Documentation</Link>
- <Link href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">Git Basics - Recording Changes</Link>
</Note>
</TabsContent>
<TabsContent value="article">
<Note type="note" title="article">
- <Link href="https://www.atlassian.com/git/tutorials/saving-changes/git-add">Atlassian Git Add Tutorial</Link>
</Note>
</TabsContent>
<TabsContent value="video">
<Note type="note" title="video">
- <Link href="https://www.youtube.com/results?search_query=git+add+tutorial">Video Tutorials</Link>
</Note>
</TabsContent>
</Tabs>
